:- module(map_test, []).
:- use_module(fiero).
:- use_module(random).
:- map(25, 25).

:- op(1000, xfy, ['#->']).

prefab { name: 'hut_s', size: p(5, 5) } #-> [
	W,W,W,W,W,
	W,C,R,R,W,
	W,R,R,R,W,
	W,R,R,R,W,
	W,W,D,W,W
] :- 
	W = [draw_point(wall)]
  , D = [draw_point(room), place_feature(door)]
  , C = [draw_point(room), place_feature(chest)]
  , R = [draw_point(room)]
.

prefab { name: 'hut_complex', size: p(12, 12) } #-> [ 
	A,_,_,_,_,R,R,B,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	R,R,R,R,R,R,R,R,R,R,R,R,
	R,R,R,R,R,R,R,R,R,R,R,R,
	C,_,_,_,_,R,R,D,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_,
	_,_,_,_,_,R,R,_,_,_,_,_
] :- 
	A = [place_prefab(hut_s, _{ rotate: 90 })]
  , B = [place_prefab(hut_s, _{ mirror_y: true, rotate: 90 })]
  , C = [place_prefab(hut_s, _{ mirror_x: true })]
  , D = [place_prefab(hut_s, _{ mirror_x: true, mirror_y: true })]
  , R = [draw_point(room)]
.
	
step{ size: p(W, H) } #-> [
	fill_rect(room, p(W, H), p(0, 0)),
	draw_rect(wall, p(W, H), p(0, 0))
].

step{ size: p(W, H) } #-> [
	draw_rect(wall, p(:=(W-5), :=(H-5)), p(5, 5)),

	draw_point(room, p(:=(W/2), 5)),
	place_feature(door, p(:=(W/2), 5)),

	draw_point(room, p(:=(W/2), :=(H-5))),
	place_feature(door, p(:=(W/2), :=(H-5)))
] :- false.

step{ } #-> [
	place_prefab(hut_complex, _{}, p(3, 3))
].


map:get_prefabs(Prefabs) :-
	findall(
		prefab { name: N, size: S, canvas: C }, 
		prefab { name: N, size: S } #-> C, 
		Prefabs).

map:generate(Step, EML) :-
	findall(
		EML_, 
		('#->'(Step, L), member(EML_, L)), 
		EML), !.