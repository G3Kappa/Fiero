% This module is imported implicitly by all game scripts.
% Do not modify unless you know what you are doing.

:- module(fiero, [as/2, '='/2, ':='/2, uuid/1, position/2, position/3, move/2]).

:- op(40, yfx, ['as']).
:- dynamic(owner/1).

%%% Shorthand macro for retrieving the player as an actor
:- expand([O] >> (
	@player :- player as actor is O
)).
:- expand([O] >> (
	@owner :- owner(O)
)).
:- dynamic(last_uuid/1).

%: AS-IS expressions are used to cast an entity-proxy to a specific type
%: NOTE: 'as' has a higher precedence than 'is', so this doesn't break arithmetic expressions
%: Example use: player as actor is _P, write_dict(_P)
Entity as Type is Proxy :-
	cast_entity(Entity, Type, Proxy).
%: Assignment of component property, mirrors dict access. Impure, modifies the state of the component.
D.Key = Val :-
	nonvar(D), 
	term_type(Key, atom),
	OldVal = D, % Calls dict_deref/2
	component_set_value(OldVal, Key, Val),
	!.
%: Assignment of component property with automatic arithmetic evaluation of the rhs.
D.Key := Val :-
	nonvar(D), 
	term_type(Key, atom),
	ground(Val),
	OldVal = D,
	Eval := Val,
	component_set_value(OldVal, Key, Eval),
	!.
%: Get entity position
position(_{ id: Id }, P) :-
	Id as physical_entity is _{ physics: _{ position: P } }, !.
%: Get entity position and floor id
position(_{ id: Id }, F, P) :-
	Id as physical_entity is _{ physics: _{ floor_id: F, position: P } }, !.

move(_{ id: Id }, P) :-
	position(_{ id: Id }, Old),
	raise(action, actor_moved, _{ actor: actor{ id: Id }, old_position: Old, new_position: P }).
%: Unify with all entities on the owner's tile (or the player if this is the shell)
here(E) :-
	(owner(O) ; player as actor is O),
    at(O, E).
%: Unify with all entities on the same tile as another physical entity
at(O, E) :-
    position(O, FloorId, Pos), % May have changed
	at(FloorId, Pos, E).

%: Generate UUID
uuid(Id) :-
	(last_uuid(Last), retract(last_uuid(Last)) ; Last = 0), !,
	Id := Last + 1,
	assertz(last_uuid(Id)).


%: Base case: Evaluate a single point
eval_point(p(X, Y), p(X, Y)).

%: Evaluation for addition of two points
eval_point(Op1 + Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 + X2,
    Y3 is Y1 + Y2.

% Evaluation for subtraction of two points
eval_point(Op1 - Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 - X2,
    Y3 is Y1 - Y2.

%: Evaluation for multiplication of two points
eval_point(Op1 * Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 * X2,
    Y3 is Y1 * Y2.

%: Evaluation for division of two points
eval_point(Op1 / Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 / X2,
    Y3 is Y1 / Y2.

%: Evaluation for addition of a point and a scalar
eval_point(p(X1, Y1) + N, p(X3, Y3)) :-
    number(N),
    X3 is X1 + N,
    Y3 is Y1 + N.

%: Evaluation for subtraction of a point and a scalar
eval_point(p(X1, Y1) - N, p(X3, Y3)) :-
    number(N),
    X3 is X1 - N,
    Y3 is Y1 - N.

%: Evaluation for multiplication of a point and a scalar
eval_point(p(X1, Y1) * N, p(X3, Y3)) :-
    number(N),
    X3 is X1 * N,
    Y3 is Y1 * N.

%: Evaluation for division of a point and a scalar
eval_point(p(X1, Y1) / N, p(X3, Y3)) :-
    number(N),
    X3 is X1 / N,
    Y3 is Y1 / N.

%: Add points or scalars
p(X3,Y3) := Op1 + Op2 :-
    eval_point(Op1 + Op2, p(X3, Y3)), !.

%: Subtract points or scalars
p(X3,Y3) := Op1 - Op2 :-
    eval_point(Op1 - Op2, p(X3, Y3)), !.

%: Multiply points or scalars
p(X3,Y3) := Op1 * Op2 :-
    eval_point(Op1 * Op2, p(X3, Y3)), !.

%: Divide points or scalars
p(X3,Y3) := Op1 / Op2 :-
    eval_point(Op1 / Op2, p(X3, Y3)), !.