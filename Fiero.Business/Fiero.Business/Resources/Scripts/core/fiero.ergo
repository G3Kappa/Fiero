% This module is imported implicitly by all game scripts.
% Do not modify unless you know what you are doing.

:- module(fiero, [as/2, '&='/2, ':='/2, uuid/1, location/2, clamp/4, owner/1]).

:- op(40, yfx, ['as']).
%: Shorthand macro for retrieving the player as an actor
:- expand([O] >> (
	@player :- player as actor is O
)).
%: Shorthand macro for retrieving the script's owner
:- expand([O] >> (
	@owner :- owner(O)
)).
:- dynamic(last_uuid/1).
:- inline([as/2]).
:- table(owner/1).
owner(O) :- owner_(O).

%: AS-IS expressions are used to cast an entity-proxy to a specific type
%: NOTE: 'as' has a higher precedence than 'is', so this doesn't break arithmetic expressions
%: Example use: player as actor is _P, write_dict(_P)
Entity as Type is Proxy :-
	cast_entity(Entity, Type, Proxy).
%: Assignment of component property, mirrors dict access. Impure, modifies the state of the component.
%D.Key &= Val :-
%	nonvar(D), 
%	term_type(Key, atom),
%	OldVal = D, % Calls dict_deref/2
%	component_set_value(OldVal, Key, Val),
%	!.
%%: Assignment of component property with automatic arithmetic evaluation of the rhs.
%D.Key := Val :-
%	nonvar(D), 
%	term_type(Key, atom),
%	ground(Val),
%	OldVal = D,
%	Eval := Val,
%	component_set_value(OldVal, Key, Eval),
%	!.
%: TODO: Figure out why this can't be inlined
location(_{ physics: _{ floor_id: FloorId, position: Pos }}, l(FloorId, Pos)).
%: Unify with all entities on the owner's tile (or the player if this is the shell)
here(E) :-
	(owner(O) ; player as actor is O),
    at(O, E).
%: Unify with all entities on the same tile as another physical entity
at(O, E) :-
    location(O, l(FloorId, Pos)),
	at(FloorId, Pos, E).

%: Generate UUID
uuid(Id) :-
	(last_uuid(Last), retract(last_uuid(Last)) ; Last = 0), !,
	Id := Last + 1,
	assertz(last_uuid(Id)).


%: Base case: Evaluate a single point
eval_point(p(X, Y), p(X, Y)).

%: Evaluation for addition of two points
eval_point(Op1 + Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 + X2,
    Y3 is Y1 + Y2.

%: Evaluation for subtraction of two points
eval_point(Op1 - Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 - X2,
    Y3 is Y1 - Y2.

%: Evaluation for multiplication of two points
eval_point(Op1 * Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 * X2,
    Y3 is Y1 * Y2.

%: Evaluation for division of two points
eval_point(Op1 / Op2, p(X3, Y3)) :-
    eval_point(Op1, p(X1, Y1)),
    eval_point(Op2, p(X2, Y2)),
    X3 is X1 / X2,
    Y3 is Y1 / Y2.

%: Evaluation for addition of a point and a scalar
eval_point(p(X1, Y1) + N, p(X3, Y3)) :-
    number(N),
    X3 is X1 + N,
    Y3 is Y1 + N.

%: Evaluation for subtraction of a point and a scalar
eval_point(p(X1, Y1) - N, p(X3, Y3)) :-
    number(N),
    X3 is X1 - N,
    Y3 is Y1 - N.

%: Evaluation for multiplication of a point and a scalar
eval_point(p(X1, Y1) * N, p(X3, Y3)) :-
    number(N),
    X3 is X1 * N,
    Y3 is Y1 * N.

%: Evaluation for division of a point and a scalar
eval_point(p(X1, Y1) / N, p(X3, Y3)) :-
    number(N),
    X3 is X1 / N,
    Y3 is Y1 / N.

%: Add points or scalars
p(X3,Y3) := Op1 + Op2 :-
    eval_point(Op1 + Op2, p(X3, Y3)), !.

%: Subtract points or scalars
p(X3,Y3) := Op1 - Op2 :-
    eval_point(Op1 - Op2, p(X3, Y3)), !.

%: Multiply points or scalars
p(X3,Y3) := Op1 * Op2 :-
    eval_point(Op1 * Op2, p(X3, Y3)), !.

%: Divide points or scalars
p(X3,Y3) := Op1 / Op2 :-
    eval_point(Op1 / Op2, p(X3, Y3)), !.

clamp(Min, Max, p(X1, Y1), p(X2, Y2)) :-
    max(Min, X1, Xm),
    max(Min, Y1, Ym),
    min(Xm, Max, X2),
    min(Ym, Max, Y2).