:- module(serializer, []).

:- subscribe(action, [actor_killed]).
:- dynamic(num_killed/1).

action:actor_killed(_{killer: @player(_)}) :- 
	( num_killed(K) 
	-> retract(num_killed(K))
	 ; K = 0
	),
	K1 := K + 1,
	assertz(num_killed(K1)),
	write(K1), write(' kills'), nl.


%%% TODO: Serialization

%%% The constant stream of events generated by the game evolves along an axis of time that is quantized in (centi)turns.
%%% The slice of every event that happened at the current time-step encodes all differences from the previous time-step.
%%% It is therefore possible to reconstruct a copy of the (opaque) game-state by keeping track of all events starting at T = 0.
%%% If this copy is sufficiently close to the original, then it can also be used as a save file from which the game can be loaded.
%%% Loading is thus implemented by playing back all the events in chronological order, patching the (opaque) game-state along the way.
%%% This is a multiplayer-friendly architecture since a common solution to the MP problem is to stream changes to an immutable game-state.

%%% Usually, Prolog databases are indexed by term. Since Ergo supports abstract terms the canonical representation of which can grow large,
%%% and since the Fiero-Ergo marshaller uses Ergo dictionaries for representing C# objects, it would be better to have an optimized db which
%%% is aware of these implementation details and can index 